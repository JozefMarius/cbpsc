{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf2 // initialize the search class\cf0 \
~cs = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build the search tree, args: nil means use the whole associated corpus (see initialization),\cf0 \
\cf2 // 	array of descriptors, last-descriptor-is-label flag... it only makes sense to use descrid\cf0 \
\cf2 //	0 or possibly 2 (cid, relID) as a label... if the flag is false, then all the descriptor\cf0 \
\cf2 //	columns in the array argument will be used to construct the kd-tree \cf0 \
~cs.buildTree(\cf3 nil\cf0 , [5, 6, 0], \cf3 true\cf0 );\
\cf2 // post the contents of the tree\cf0 \
~cs.tree.allNearest.do(\{\cf3 |res|\cf0  \cf4 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // build a tree, but normalize the values to 0. -> 1. range\cf0 \
\cf2 // - this is done so that searches can be equally weighted accross dimensions of the tree\cf0 \
~cs.buildNormalizedTree(\cf3 nil\cf0 , [5, 6, 0]);\
\cf2 // again, post the contents...\cf0 \
~cs.normedTree.allNearest.do(\{\cf3 |res|\cf0  \cf4 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // using the normalized tree..\cf0 \
\cf2 // search within circular bounds\cf0 \
~cs.findNearestInRadius([0.9, 0.1], 0.25);\
\
\
~cs.tree.nearest([101, 0.7262])[0].location;\
\
~cs.tree.rectSearch([80, 0.7], [90, 0.8]).do(\{ \cf3 |kdt|\cf0  [kdt.location, (kdt.location - [85, 0.75]).abs, kdt.label].postln \});\
\
\
~cs2 = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build a normed tree with amp, first 10 mfccs\cf0 \
~cs2.buildNormalizedTree(\cf3 nil\cf0 , [7] ++ (16..25) ++ 0, \cf3 true\cf0 );\
~cs2.normedTree.allNearest.do(\{\cf3 |res|\cf0  \cf4 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // center of mass for N units\cf0 \
\
~map = ~crps.mapSoundFileUnitsToCorpusUnits;\
~accum = \cf3 Array\cf0 .fillND([10], \{0\});\
~map.pairsDo(\{ \cf3 |key, val|\cf0 \
	\cf3 var\cf0  row = ([val[8], val[16..25]]).flatten;\
	~accum = ~accum + row\
\});\
\cf2 // average or 'center of mass' of the units\cf0 \
~accum / ~map.size;\
\
\
\
~cs3 = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build a normed tree with first 10 mfccs\cf0 \
~cs3.buildNormalizedTree(\cf3 nil\cf0 , (16..25) ++ 0, \cf3 true\cf0 );\
\
\cf2 // N (5) nearest nodes; less or none may be found!\cf0 \
\
~cs3.normedTree.do(\{ \cf3 |node|\cf0 \
	\cf3 var\cf0  res;\
	[node.label, node.location].post; \cf4 ":"\cf0 .postln;\
	res = ~cs3.findNNearest(node.location, 0.5, 5);\
	res.do(\{ \cf3 |pair|\cf0 \
		(pair[0].asInteger != node.label.asInteger).if \{ pair[0].post; \cf4 " "\cf0 .post; \};\
	\});\
	\cf4 " "\cf0 .postln;\
		\
\});\
\
}