{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf2 // 0.\cf3 \
\cf2 // Build a corpus to use for the examples...\cf3 \
\
\cf4 Server\cf3 .default = \cf4 Server\cf3 .internal;\
s = \cf4 Server\cf3 .default.boot;\
~crps = \cf4 CorpusDB\cf3 .new(\cf5 \\synthtest\cf3 , s);\
\
\
\
~testpath = \cf6 "/Users/tms/dev/supercollider/drone.piece.0000/snd/droning/21215_voice_chant_drone_low_overtone.aif"\cf3 ; \cf2 // substitute your own sound file path\cf3 \
~crps.addSoundFile(~testpath, 2); \cf2 // change 2 to 1 if mono\cf3 \
\
\cf2 // analyze + create lots of segments\cf3 \
~crps.analyzeSoundFile(~testpath);\
\
(\
\cf4 var\cf3  numsegments = (~crps[\cf5 \\sftable\cf3 ][~testpath][\cf5 \\bfrL\cf3 ].duration / 0.5).floor;\
(0..(numsegments - 1)).do(\{ \cf4 |generated, index|\cf3 \
	~crps.addSoundFileUnit(~testpath, index, [((generated / 2) * 1000), 500]);\
\});\
)\
\
\cf2 // segment the units (after analyzeSoundFile is done)\cf3 \
\cf2 // this function should be renamed analyzeUnits, since they are already 'segmented' by a\cf3 \
\cf2 // series of addSoundFileUnits calls\cf3 \
~crps.segmentUnits(~testpath);\
\cf2 // export so we don't have to repeat analysis to do these examples again\cf3 \
~crps.exportCorpusToXML(s, \cf6 "/Users/tms/dev/supercollider/drone.piece.0000/xml/corpus-search-example.xml"\cf3 ); \cf2 // change the file path here and in each example to export and import on your machine\cf3 \
\
\
\cf2 // 1.\cf3 \
~crps.importCorpusFromXML(s, \cf6 "/Users/tms/dev/supercollider/drone.piece.0000/xml/corpus-search-example.xml"\cf3 );\
\cf2 // initialize the search class\cf3 \
~cs = \cf4 CorpusSearch\cf3 (~crps);\
\cf2 // build the search tree, args: nil means use the whole associated corpus (see initialization),\cf3 \
\cf2 // 	array of descriptors, last-descriptor-is-label flag... it only makes sense to use descrid\cf3 \
\cf2 //	0 or possibly 2 (cid, relID) as a label... if the flag is false, then all the descriptor\cf3 \
\cf2 //	columns in the array argument will be used to construct the kd-tree and there are no labels\cf3 \
~cs.buildTree(\cf4 nil\cf3 , [5, 6, 0], \cf4 true\cf3 );\
\cf2 // post the contents of the tree\cf3 \
~cs.tree.allNearest.do(\{\cf4 |res|\cf3  \cf6 "(%, % -> %, %)"\cf3 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // build a tree, but normalize the values to 0. -> 1. range\cf3 \
\cf2 // - this is done so that searches can be equally weighted accross dimensions of the tree\cf3 \
~cs.buildNormalizedTree(\cf4 nil\cf3 , [5, 6, 0]);\
\cf2 // again, post the contents...\cf3 \
~cs.normedTree.allNearest.do(\{\cf4 |res|\cf3  \cf6 "(%, % -> %, %)"\cf3 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // using the normalized tree, internally..\cf3 \
\cf2 // search within circular bounds\cf3 \
~cs.findNearestInRadius([0.9, 0.1], 0.25);\
\cf2 // search using a point in the KD-Tree\cf3 \
~cs.tree.nearest([101, 0.7262])[0].location;\
\cf2 // search using a rectangular search area\cf3 \
~cs.tree.rectSearch([80, 0.7], [90, 0.8]).do(\{ \cf4 |kdt|\cf3  [kdt.location, (kdt.location - [85, 0.75]).abs, kdt.label].postln \});\
\
\cf2 // 2.\cf3 \
\cf2 // In this example we will constuct a normalized tree using part of each unit row.\cf3 \
\cf2 // Then we will compute centers of mass of the corpus and sub-corpora (sub-groups)\cf3 \
\
~cs2 = \cf4 CorpusSearch\cf3 (~crps);\
\cf2 // build a normed tree with amp, first 10 mfcc coefficients\cf3 \
~cs2.buildNormalizedTree(\cf4 nil\cf3 , [7] ++ (16..25) ++ 0, \cf4 true\cf3 );\
\cf2 // post each node with its nearest neighbor\cf3 \
~cs2.normedTree.allNearest.do(\{\cf4 |res|\cf3  \cf6 "(%, % -> %, %)"\cf3 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // center of mass for N units\cf3 \
~map = ~crps.mapSoundFileUnitsToCorpusUnits;\
~accum = \cf4 Array\cf3 .fillND([10], \{0\});\
~map.pairsDo(\{ \cf4 |key, val|\cf3 \
	\cf4 var\cf3  row = ([val[8], val[16..25]]).flatten;\
	~accum = ~accum + row\
\});\
\cf2 // average or 'center of mass' of all the units\cf3 \
~accum / ~map.size;\
\
\
\cf2 // now, centers of masses for sub-corpora, in this case: units grouped by the sound file from which they come\cf3 \
\
\cf2 // to do...\cf3 \
\
\cf2 // 3.\cf3 \
\cf2 // Now we will look for the 5 nearest nodes to each node in a corpus\cf3 \
\cf2 // findNNearest takes 3 arguments: target node location, the search radius (in normalized range,\cf3 \
\cf2 // 0. -> 1.), and the max number of nearby nodes to return\cf3 \
~cs3 = \cf4 CorpusSearch\cf3 (~crps);\
\cf2 // build a normed tree with first 10 mfccs\cf3 \
~cs3.buildNormalizedTree(\cf4 nil\cf3 , (16..25) ++ 0, \cf4 true\cf3 );\
\
\cf2 // N (5) nearest nodes; note that less than N or no (0) nodes may be found!\cf3 \
~cs3.normedTree.do(\{ \cf4 |node|\cf3 \
	\cf4 var\cf3  res;\
	[node.label, node.location].post; \cf6 ":"\cf3 .postln;\
	res = ~cs3.findNNearest(node.location, 0.5, 5);\
	res.do(\{ \cf4 |pair|\cf3 \
		(pair[0].asInteger != node.label.asInteger).if \{ pair[0].post; \cf6 " "\cf3 .post; \};\
	\});\
	\cf6 " "\cf3 .postln;\
		\
\});\
\
\
\cf2 // 4.\cf3 \
\cf2 // The previous examples show some of the kd-tree search features. The CorpusSearch class also\cf3 \
\cf2 // keeps track of stats for your corpus (and, soon, sub-corpora).\cf3 \
~cs4 = \cf4 CorpusSearch\cf3 (~crps);\
~cs4.getStats.postcs;\
\
\cf2 // the same as getStats, but \cf3 \
~map = ~crps.mapSoundFileUnitsToCorpusUnits;\
~stats = ~map.keys.asArray.sort.collect(\{ \cf4 |row|\cf3  ~map[row] \}).flop.collect(\{ \cf4 |col|\cf3 \
	\cf4 var\cf3  stdev, mean = col.mean;\
	\cf2 // the only complicated part is the calculation of standard deviation\cf3 \
	stdev = col.inject(0, \{ \cf4 |sum, cell|\cf3  sum + ((cell - mean) ** 2) \});\
	[col.minItem, col.maxItem, col.maxItem - col.minItem, mean, (stdev / col.size).sqrt]\
\});\
\
}