{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs20 \cf2 //This file is part of cbpsc (last revision @ version 0.2).\cf0 \
\cf2 //\cf0 \
\cf2 //cbpsc is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\cf0 \
\cf2 //\cf0 \
\cf2 //cbpsc is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\cf0 \
\cf2 //\cf0 \
\cf2 //You should have received a copy of the GNU General Public License along with cbpsc.  If not, see <http://www.gnu.org/licenses/>.\cf0 \
\cf2 //\cf0 \
\cf2 // cbpsc : created by Thomas Stoll : tms@corpora-sonorus.com : www.corpora-sonorus.com\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 //\
// Copyright 2010-11, Thomas Stoll\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf2 \
// 0.\cf0 \
\cf2 // Build a corpus to use for the examples...\cf0 \
\
\cf3 Server\cf0 .default = \cf3 Server\cf0 .internal;\
s = \cf3 Server\cf0 .default.boot;\
~crps = \cf3 CorpusDB\cf0 .new(\cf4 \\synthtest\cf0 , s);\
\
\
\
~testpath = \cf5 "/Users/tms/dev/supercollider/drone.piece.0000/snd/droning/21215_voice_chant_drone_low_overtone.aif"\cf0 ; \cf2 // substitute your own sound file path\cf0 \
~crps.addSoundFile(~testpath, 2); \cf2 // change 2 to 1 if mono\cf0 \
\
\cf2 // analyze + create lots of segments\cf0 \
~crps.analyzeSoundFile(~testpath);\
\
(\
\cf3 var\cf0  numsegments = (~crps[\cf4 \\sftable\cf0 ][~testpath][\cf4 \\bfrL\cf0 ].duration / 0.5).floor;\
(0..(numsegments - 1)).do(\{ \cf3 |generated, index|\cf0 \
	~crps.addSoundFileUnit(~testpath, index, [((generated / 2) * 1000), 500]);\
\});\
)\
\
\cf2 // segment the units (after analyzeSoundFile is done)\cf0 \
\cf2 // this function should be renamed analyzeUnits, since they are already 'segmented' by a\cf0 \
\cf2 // series of addSoundFileUnits calls\cf0 \
~crps.segmentUnits(~testpath);\
\cf2 // export so we don't have to repeat analysis to do these examples again\cf0 \
~crps.exportCorpusToXML(s, \cf5 "/Users/tms/dev/supercollider/drone.piece.0000/xml/corpus-search-example.xml"\cf0 ); \cf2 // change the file path here and in each example to export and import on your machine\cf0 \
\
\
\cf2 // 1.\cf0 \
~crps.importCorpusFromXML(s, \cf5 "/Users/tms/dev/supercollider/drone.piece.0000/xml/corpus-search-example.xml"\cf0 );\
\cf2 // initialize the search class\cf0 \
~cs = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build the search tree, args: nil means use the whole associated corpus (see initialization),\cf0 \
\cf2 // 	array of descriptors, last-descriptor-is-label flag... it only makes sense to use descrid\cf0 \
\cf2 //	0 or possibly 2 (cid, relID) as a label... if the flag is false, then all the descriptor\cf0 \
\cf2 //	columns in the array argument will be used to construct the kd-tree and there are no labels\cf0 \
~cs.buildTree(\cf3 nil\cf0 , [5, 6, 0], \cf3 true\cf0 );\
\cf2 // post the contents of the tree\cf0 \
~cs.tree.allNearest.do(\{\cf3 |res|\cf0  \cf5 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // build a tree, but normalize the values to 0. -> 1. range\cf0 \
\cf2 // - this is done so that searches can be equally weighted accross dimensions of the tree\cf0 \
~cs.buildNormalizedTree(\cf3 nil\cf0 , [5, 6, 0]);\
\cf2 // again, post the contents...\cf0 \
~cs.normedTree.allNearest.do(\{\cf3 |res|\cf0  \cf5 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // using the normalized tree, internally..\cf0 \
\cf2 // search within circular bounds\cf0 \
~cs.findNearestInRadius([0.9, 0.1], 0.25);\
\cf2 // search using a point in the KD-Tree\cf0 \
~cs.tree.nearest([101, 0.7262])[0].location;\
\cf2 // search using a rectangular search area\cf0 \
~cs.tree.rectSearch([80, 0.7], [90, 0.8]).do(\{ \cf3 |kdt|\cf0  [kdt.location, (kdt.location - [85, 0.75]).abs, kdt.label].postln \});\
\
\cf2 // 2.\cf0 \
\cf2 // In this example we will constuct a normalized tree using part of each unit row.\cf0 \
\cf2 // Then we will compute centers of mass of the corpus and sub-corpora (sub-groups)\cf0 \
\
~cs2 = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build a normed tree with amp, first 10 mfcc coefficients\cf0 \
~cs2.buildNormalizedTree(\cf3 nil\cf0 , [7] ++ (16..25) ++ 0, \cf3 true\cf0 );\
\cf2 // post each node with its nearest neighbor\cf0 \
~cs2.normedTree.allNearest.do(\{\cf3 |res|\cf0  \cf5 "(%, % -> %, %)"\cf0 .format(res.key.label, res.key.location, res.value[0].location, res.value[0].label).postln\});\
\
\cf2 // center of mass for N units\cf0 \
~map = ~crps.mapSoundFileUnitsToCorpusUnits;\
~accum = \cf3 Array\cf0 .fillND([10], \{0\});\
~map.pairsDo(\{ \cf3 |key, val|\cf0 \
	\cf3 var\cf0  row = ([val[8], val[16..25]]).flatten;\
	~accum = ~accum + row\
\});\
\cf2 // average or 'center of mass' of all the units\cf0 \
~accum / ~map.size;\
\
\
\cf2 // now, centers of masses for sub-corpora, in this case: units grouped by the sound file from which they come\cf0 \
\
\cf2 // to do...\cf0 \
\
\cf2 // 3.\cf0 \
\cf2 // Now we will look for the 5 nearest nodes to each node in a corpus\cf0 \
\cf2 // findNNearest takes 3 arguments: target node location, the search radius (in normalized range,\cf0 \
\cf2 // 0. -> 1.), and the max number of nearby nodes to return\cf0 \
~cs3 = \cf3 CorpusSearch\cf0 (~crps);\
\cf2 // build a normed tree with first 10 mfccs\cf0 \
~cs3.buildNormalizedTree(\cf3 nil\cf0 , (16..25) ++ 0, \cf3 true\cf0 );\
\
\cf2 // N (5) nearest nodes; note that less than N or no (0) nodes may be found!\cf0 \
~cs3.normedTree.do(\{ \cf3 |node|\cf0 \
	\cf3 var\cf0  res;\
	[node.label, node.location].post; \cf5 ":"\cf0 .postln;\
	res = ~cs3.findNNearest(node.location, 0.5, 5);\
	res.do(\{ \cf3 |pair|\cf0 \
		(pair[0].asInteger != node.label.asInteger).if \{ pair[0].post; \cf5 " "\cf0 .post; \};\
	\});\
	\cf5 " "\cf0 .postln;\
		\
\});\
\
\
\cf2 // 4.\cf0 \
\cf2 // The previous examples show some of the kd-tree search features. The CorpusSearch class also\cf0 \
\cf2 // keeps track of stats for your corpus (and, soon, sub-corpora).\cf0 \
~cs4 = \cf3 CorpusSearch\cf0 (~crps);\
~cs4.getStats.postcs;\
\
\cf2 // the same as getStats, but \cf0 \
~map = ~crps.mapSoundFileUnitsToCorpusUnits;\
~stats = ~map.keys.asArray.sort.collect(\{ \cf3 |row|\cf0  ~map[row] \}).flop.collect(\{ \cf3 |col|\cf0 \
	\cf3 var\cf0  stdev, mean = col.mean;\
	\cf2 // the only complicated part is the calculation of standard deviation\cf0 \
	stdev = col.inject(0, \{ \cf3 |sum, cell|\cf0  sum + ((cell - mean) ** 2) \});\
	[col.minItem, col.maxItem, col.maxItem - col.minItem, mean, (stdev / col.size).sqrt]\
\});\
\
}