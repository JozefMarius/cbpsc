{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs18 \cf2 //This file is part of cbpsc (version 0.1.2).\cf0 \
\cf2 //\cf0 \
\cf2 //cbpsc is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\cf0 \
\cf2 //\cf0 \
\cf2 //cbpsc is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\cf0 \
\cf2 //\cf0 \
\cf2 //You should have received a copy of the GNU General Public License along with cbpsc.  If not, see <http://www.gnu.org/licenses/>.\cf0 \
\cf2 //\cf0 \
\cf2 // cbpsc : created by Thomas Stoll : tms@corpora-sonorus.com : www.corpora-sonorus.com\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 //\cf0 \
\cf2 // Copyright 2010, Thomas Stoll\cf0 \
\
\cf2 // 1. evaluate the parenthasized functions\cf0 \
(\
~newSoundFileUnitRow = \{ \cf3 |currfile, pid, parent, top, bot|\cf0 \
	\cf3 var\cf0  currSFU = ~crps[\cf4 \\sfutable\cf0 ][currfile];\
	[ \cf3 SCButton\cf0 .new(parent, \cf3 Rect\cf0 (0, (pid * 25), 22, 22))\
			.states_([[pid.asString, \cf3 Color\cf0 .blue, \cf3 Color\cf0 .white], [pid.asString, \cf3 Color\cf0 .white, \cf3 Color\cf0 .blue]])\
			.value_(0)\
			.mouseUpAction_(\{ \cf3 |bttn|\cf0 \
				~updateSFViews.value(currfile, top, bot, pid);\
				\cf3 Plotter\cf0 (parent: ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\highlighter\cf0 ])\
					.value_(currSFU[\cf4 \\mfccs\cf0 ][pid][6..].ampdb)\
\pard\pardeftab560\ql\qnatural
\cf0 					.plotMode_(\cf4 \\plines\cf0 )\
					.findSpecs_(\cf3 true\cf0 );\
			\}),\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 		\cf3 SCButton\cf0 .new(parent, \cf3 Rect\cf0 (25, (pid * 25), 22, 22))\
			.states_([[\cf5 "X"\cf0 , \cf3 Color\cf0 .white, \cf3 Color\cf0 .red]])\
			.value_(0)\
			.mouseUpAction_(\{ \cf3 |num|\cf0  \cf3 AppClock\cf0 .sched(0, \{\cf3 |now|\cf0  ~deleteSoundFileUnit.value(pid, top, bot); \cf3 nil\cf0 \}) \}),\
		\cf3 SCButton\cf0 .new(parent, \cf3 Rect\cf0 (50, (pid * 25), 22, 22))\
			.states_([[\cf5 "P"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .green]])\
			.value_(0)\
			.mouseUpAction_(\{ ~playSegment.value([currfile, pid]) \}),\
\pard\pardeftab560\ql\qnatural
\cf0 		\cf3 SCNumberBox\cf0 .new(parent, \cf3 Rect\cf0 (75, (pid * 25), 60, 20))\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 			.value_(currSFU[\cf4 \\units\cf0 ][pid][4])\
			.action_(\{\cf3 |val|\cf0  \cf2 // "ONSET VAL: ".post; val.value.postln;\cf0 \
				~crps.updateSoundFileUnit(currfile, pid, \cf3 nil\cf0 , val.value.floor);\
				~crps.segmentUnits(currfile);\
				~updateSFViews.value(currfile, top, bot, pid);\
\cf2 //				~updateCurrentSoundFileUnit.value(pid,1);\cf0 \
				~gui[\cf4 \\soundFileUnitRowViews\cf0 ][pid][5].value_(currSFU[\cf4 \\units\cf0 ][pid][0..16].asString);\
			\}),\
		\cf3 SCNumberBox\cf0 .new(parent, \cf3 Rect\cf0 (140, (pid * 25), 60, 20))\
			.value_(currSFU[\cf4 \\units\cf0 ][pid][5])\
			.action_(\{\cf3 |val|\cf0  \cf2 // "DUR VAL: ".post; val.value.postln;\cf0 \
				~crps.updateSoundFileUnit(currfile, pid, \cf3 nil\cf0 , \cf3 nil\cf0 , val.value.ceil);\
				~crps.segmentUnits(currfile);\
				~updateSFViews.value(currfile, top, bot, pid);\
\cf2 //				~updateCurrentSoundFileUnit.value(pid,1);\cf0 \
				~gui[\cf4 \\soundFileUnitRowViews\cf0 ][pid][5].value_(currSFU[\cf4 \\units\cf0 ][pid][0..16].asString);\
			\}),\
		\cf3 SCTextField\cf0 .new(parent, \cf3 Rect\cf0 (205, (pid * 25), 700, 20))\
			.value_(currSFU[\cf4 \\units\cf0 ][pid][0..16].asString), \cf2 //((++ ~crps[\\sfutable][currfile][\\units][pid][5..15]).asString),\cf0 \
		pid.asInteger ];\
\};\
\
~updateSoundFileUnitRow = \{ \cf3 |rid, bot|\cf0 \
	[rid, bot].postln;\
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ][rid][3].value_(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][rid][4]); \cf2 ////!!!!!!!!!\cf0 \
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ][rid][4].value_(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][rid][5]);\
	bot.setSelection(rid, [0, 0]);\
	bot.setSelection(rid, ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][rid][4..5] * 44.1);\
	\cf2 //"Row ".post; rid.post; " updated.".postln;\cf0 \
\};\
\
~updateSFViews = \{ \cf3 |cfpath, top, bot, currid|\cf0 \
	\cf3 var\cf0  theunits = ~crps[\cf4 \\sfutable\cf0 ][cfpath][\cf4 \\units\cf0 ];\
	theunits.postln;\
	\cf2 // clear Views\cf0 \
	(0..63).do(\{ \cf3 |i|\cf0  top.selectNone(i) \});\
	bot.selectNone(0);\
	\cf2 // read out units into the two views if they exist\cf0 \
	(theunits != \cf3 nil\cf0 ).if\
	\{\
		theunits.do(\{ \cf3 |row, index|\cf0  top.setSelection(index, [row[4], row[5]] * 44.1) \});\
		bot.setSelection(0, (theunits[currid][4..5] * 44.1));\
		\cf2 //unselect\cf0 \
		(~gui[\cf4 \\soundFileUnitRowViews\cf0 ][~gui[\cf4 \\cp\cf0 ]] != \cf3 nil\cf0 ).if \{ ~gui[\cf4 \\soundFileUnitRowViews\cf0 ][~gui[\cf4 \\cp\cf0 ]][0].value_(0)\};\
		\cf2 //update\cf0 \
		~gui[\cf4 \\cp\cf0 ] = currid;\
		~gui[\cf4 \\soundFileUnitRowViews\cf0 ][~gui[\cf4 \\cp\cf0 ]][0].value_(0);\
		\cf2 //~updateCurrentSoundFileUnit.value(currid,1);\cf0 \
	\};\
\};\
\
~updateCurrentSoundFileUnit = \{ \cf3 |cpuid|\cf0 \
	\cf2 //unselect\cf0 \
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ][~gui[\cf4 \\cp\cf0 ]][0].value_(0);\
	\cf2 //update\cf0 \
	~gui[\cf4 \\cp\cf0 ] = cpuid;\
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ][~gui[\cf4 \\cp\cf0 ]][0].value_(0);\
\};\
\
~deleteSoundFileUnit = \{ \cf3 |did, top, bot|\cf0 \
	\cf3 var\cf0  range, num = ~gui[\cf4 \\soundFileUnitRowViews\cf0 ][did].pop;\
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ][did].do(\{\cf3 |item|\cf0  item.remove; item.free \});\
	top.setSelection(~gui[\cf4 \\cp\cf0 ], [0, 0]);\
	top.setSelection((~gui[\cf4 \\soundFileUnitRowViews\cf0 ].size - 1), [0, 0]);\
	bot.setSelection(0, [0, 0]);\
	~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add(did->\cf3 nil\cf0 );\
	~graphNeedsUpdate = \cf3 true\cf0 ;\
	\
	range = ~crps.removeSoundFileUnit(~gui[\cf4 \\cf\cf0 ], did);\
\cf2 //	"Popping this provisional unit: ".post; num.postln;\cf0 \
\cf2 //	"Range: ".post;	range.postln;\cf0 \
	(range != \cf3 nil\cf0 ).if\
	\{	\
		range.do(\{ \cf3 |rv|\cf0 \
			\cf3 var\cf0  waveformArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ];\
			\cf3 var\cf0  tmp = ~newSoundFileUnitRow.value(~gui[\cf4 \\cf\cf0 ], rv, ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segments\cf0 ][\cf4 \\view\cf0 ], waveformArea[\cf4 \\fullView\cf0 ], waveformArea[\cf4 \\closeView\cf0 ]); \cf2 // the data model has already been updated!!!!\cf0 \
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add(rv -> tmp);\
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ][rv + 1].pop;\
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ][rv + 1].do(\{\cf3 |item|\cf0  item.remove; item.free \});\
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add((rv + 1) -> \cf3 nil\cf0 );\
		\});\
	\};\
\
	(~gui[\cf4 \\soundFileUnitRowViews\cf0 ].size > 0).if\
	\{\
		~updateCurrentSoundFileUnit.value(~gui[\cf4 \\cp\cf0 ] % ~gui[\cf4 \\soundFileUnitRowViews\cf0 ].size);\
		(~gui[\cf4 \\cp\cf0 ]..(~gui[\cf4 \\soundFileUnitRowViews\cf0 ].size - 1)).do(\{ \cf3 |prow|\cf0 	\
			top.setSelection(prow, ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][prow][4..5] * 44.1);\
		\});\
		bot.setSelection(0, ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][~gui[\cf4 \\cp\cf0 ]][4..5] * 44.1);\
	\};\
	~crps.segmentUnits(~gui[\cf4 \\cf\cf0 ]);\
\};\
\
~buildGraphParams = \{ \cf3 |tabnum, xx, yy, ss, dragtarget = nil, fontcolor, initSelection|\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 	\cf3 var\cf0  descrids = \cf3 Array\cf0 [], selected;\
	\cf3 var\cf0  graph = ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ], graphparams = ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ];\
	\cf3 var\cf0  gpheight = graphparams[\cf4 \\view\cf0 ].bounds.height;\
\
	~crps[\cf4 \\dtable\cf0 ].keys.asArray.sort.do(\{ \cf3 |descr|\cf0  descrids = descrids.add(~crps[\cf4 \\dtable\cf0 ][descr].asString) \});\
	~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\xx\cf0 ] = ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\xx\cf0 ] ? xx;\
	~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\yy\cf0 ] = ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\yy\cf0 ] ? yy;\
	~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\ss\cf0 ] = ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\ss\cf0 ] ? ss;\
	\
	~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\view\cf0 ].children.do(\{\cf3 |child|\cf0  child.remove; child.free \});\
	\cf5 "BUILDING GRAPH PARAMS!!!"\cf0 .postln;\
	\
	graph.sync;\
	graph.descriptors_(xx, yy, ss).fontColor_(fontcolor).dragTarget_(dragtarget).zoomFactor_(1@1).transFactor_(0@0);\
	graph.clients_([	\cf2 // unitData Viewer, player, MFCC plotter\cf0 \
		\{ \cf3 |chosen1|\cf0  graphparams[\cf4 \\unitData\cf0 ].items_(~crps.getSoundFileUnitMetadata(chosen1.state[0], chosen1.state[1])[0..16].collect(\{\cf3 |elem|\cf0  elem.asString\})) \},	\cf2 // link scene to metadata view \cf0 \
		\{ \cf3 |chosen2|\cf0  ~playSegment.value(chosen2.state) \},\
		\{ \cf3 |chosen3|\cf0 \
			\cf3 Plotter\cf0 (parent: ~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\highlighter\cf0 ])\
				.value_(~crps[\cf4 \\sfutable\cf0 ][ ~crps[\cf4 \\sfmap\cf0 ][chosen3.state[0]] ][\cf4 \\mfccs\cf0 ][chosen3.state[1]][6..].ampdb)\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 				.plotMode_(\cf4 \\plines\cf0 )\
\pard\pardeftab560\ql\qnatural
\cf0 				.findSpecs_(\cf3 true\cf0 );\
		\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 	]);\
	graph.highlight([0,0]);\
	\cf2 // the 4 columns: names, mins, currently selected unit, maxes\cf0 \
	graphparams[\cf4 \\minList\cf0 ].remove;\
	graphparams[\cf4 \\unitData\cf0 ].remove;\
	graphparams[\cf4 \\maxList\cf0 ].remove;\
	\
\cf2 //	~gui[\\tabs][1][\\areas][\\graph].cArray.postln;\cf0 \
	\
	graphparams.add(\cf4 \\dList\cf0  -> \cf3 SCListView\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0, 25, 80, gpheight - 25))\
			.stringColor_(\cf3 Color\cf0 .white).selectedStringColor_(\cf3 Color\cf0 .green)\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 			.items_(~crps[\cf4 \\dtable\cf0 ].keys.asArray.sort.collect(\{ \cf3 |descr|\cf0  ~crps[\cf4 \\dtable\cf0 ][descr].asString \})))\
		.add(\cf4 \\xLabel\cf0  -> \cf3 StaticText\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (85, 5, 80, 20))\
			.string_(\cf5 "X"\cf0 ).stringColor_(\cf3 Color\cf0 .green))\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 		.add(\cf4 \\minList\cf0  -> \cf3 SCListView\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (85, 25, 80, gpheight - 25))\
			.stringColor_(\cf3 Color\cf0 .white).selectedStringColor_(\cf3 Color\cf0 .green)\
			.items_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ].cArray[0..16].collect(\{\cf3 |col|\cf0  col.minItem.asString \}))\
			.value_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\xx\cf0 ])\
			.action_(\{ \cf3 |selection|\cf0 \
				graph.descriptors_(selection.value.max(0).min(descrids.size),\
					~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\unitData\cf0 ].value,\
					~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\maxList\cf0 ].value\
				)\
			\}))\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 		.add(\cf4 \\yLabel\cf0  -> \cf3 StaticText\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (170, 5, 80, 20))\
			.string_(\cf5 "Y"\cf0 ).stringColor_(\cf3 Color\cf0 .green))\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 		.add(\cf4 \\unitData\cf0  -> \cf3 SCListView\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (170, 25, 80, gpheight - 25))\
			.stringColor_(\cf3 Color\cf0 .white).selectedStringColor_(\cf3 Color\cf0 .green)\
			.items_(~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ].cArray.flop[0][0..16].collect(\{\cf3 |item|\cf0  item.asString \}))\
			.value_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\yy\cf0 ])\
			.action_(\{ \cf3 |selection|\cf0 \
				graph.descriptors_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\minList\cf0 ].value,\
					selection.value.max(0).min(descrids.size),\
					~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\maxList\cf0 ].value\
				)\
			\}))\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 		.add(\cf4 \\sLabel\cf0  -> \cf3 StaticText\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (255, 5, 80, 20))\
			.string_(\cf5 "S"\cf0 ).stringColor_(\cf3 Color\cf0 .green))\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 		.add(\cf4 \\maxList\cf0  -> \cf3 SCListView\cf0 (graphparams[\cf4 \\view\cf0 ], \cf3 Rect\cf0 (255, 25, 80, gpheight - 25))\
			.stringColor_(\cf3 Color\cf0 .white).selectedStringColor_(\cf3 Color\cf0 .green)\
			.items_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ].cArray[0..16].collect(\{\cf3 |col|\cf0  col.maxItem.asString \}))\
			.value_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\ss\cf0 ])\
			.action_(\{ \cf3 |selection|\cf0 \
				graph.descriptors_(~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\minList\cf0 ].value,\
					~gui[\cf4 \\tabs\cf0 ][tabnum][\cf4 \\areas\cf0 ][\cf4 \\graphParams\cf0 ][\cf4 \\unitData\cf0 ].value,\
					selection.value.max(0).min(descrids.size)\
				)\
			\}));\
\};\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 \
~scheduleUpdates = \{ \cf3 |num|\cf0 \
	(num == 0).if \{ (1..3).do(\{ \cf3 |n|\cf0  ~gui[\cf4 \\tabs\cf0 ][n][\cf4 \\needsUpdate\cf0 ] = \cf3 true\cf0  \}) \} \{ ~gui[\cf4 \\tabs\cf0 ][num][\cf4 \\needsUpdate\cf0 ] = \cf3 true\cf0  \};\
\};\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 ~playSegment = \{ \cf3 |pair|\cf0 \
	\cf3 var\cf0  cf, relid = pair[1];\
	(pair[0].isNumber).if \{ cf = ~crps[\cf4 \\sfmap\cf0 ][pair[0]] \} \{ cf = pair[0] \};\
	\cf5 "Playing unit number: "\cf0 .post; relid.post; \cf5 ", from "\cf0 .post; cf.postln;\
	\cf3 Post\cf0  << \cf5 "offset: "\cf0  << (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][4] * 0.001) << \cf5 " dur: "\cf0  << (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][5] * 0.001) << \cf3 Char\cf0 .nl;\
	(~crps[\cf4 \\sftable\cf0 ][ cf ][\cf4 \\bfrR\cf0 ] == \cf3 nil\cf0 ).if\
	\{\
		\cf5 "PLAYING MONO"\cf0 .postln;\
		~audio[\cf4 \\monoPlayer\cf0 ].set(\cf4 \\bufNum\cf0 , ~crps[\cf4 \\sftable\cf0 ][ cf ][\cf4 \\bfrL\cf0 ].bufnum, \cf4 \\offset\cf0 , (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][4] * 0.001), \cf4 \\dur\cf0 , (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][5] * 0.001));	\cf2 // msecs -> secs\cf0 \
		~audio[\cf4 \\mBus\cf0 ].set(1);\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 	\} \{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 		\cf5 "PLAYING STEREO"\cf0 .postln;\
		~audio[\cf4 \\stereoPlayer\cf0 ].set(\cf4 \\bufNumL\cf0 , ~crps[\cf4 \\sftable\cf0 ][ cf ][\cf4 \\bfrL\cf0 ].bufnum, \cf4 \\bufNumR\cf0 , ~crps[\cf4 \\sftable\cf0 ][ cf ][\cf4 \\bfrR\cf0 ].bufnum, \cf4 \\offset\cf0 , (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][4] * 0.001), \cf4 \\dur\cf0 , (~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\units\cf0 ][relid][5] * 0.001));	\cf2 // msecs -> secs\cf0 \
		~audio[\cf4 \\sBus\cf0 ].set(1);\
	\}\
\};\
)\
\
\cf2 ////***********************************************************************************************\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 ////		Load Audio Server + Send SynthDefs\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 \
\cf2 // 2., 3., 4. evaluate the following 3 lines\cf0 \
\cf3 Server\cf0 .default = \cf3 Server\cf0 .internal;\
~audio = \cf3 Dictionary\cf0 [];\
~audio.add(\cf4 \\server\cf0  -> \cf3 Server\cf0 .default.boot);\
\pard\pardeftab560\li1700\fi-1700\ql\qnatural
\cf0 \
\cf2 // 5. evaluate the following to send 2 synthdefs to the server\cf0 \
(\
\cf3 SynthDef\cf0 .new(\cf4 \\unitSamplerMono\cf0 , \{ \cf3 |out=0, busTrig=1, bufNum, transp=1, offset=0,attack=0.01,dur=1,release=0.5, pan=0, da=0|\cf0 \
	\cf3 var\cf0  env, chunk, inTrig;\
	inTrig = \cf3 InTrig\cf0 .kr(busTrig);\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .linen(attack, (dur - attack - release), release, 1), gate: inTrig, doneAction: da);\
	chunk = \cf3 PlayBuf\cf0 .ar(1, bufNum, transp, inTrig, (offset.max(0).min(\cf3 BufDur\cf0 .kr(bufNum) - dur) * \cf3 BufSampleRate\cf0 .kr(bufNum)));\
	\cf3 Out\cf0 .ar( out, \cf3 Pan2\cf0 .ar(chunk * env, pan) );\
\}).send(~audio[\cf4 \\server\cf0 ]);\
\
\cf3 SynthDef\cf0 .new(\cf4 \\unitSamplerStereo\cf0 , \{ \cf3 |out=0, busTrig=1, bufNumL, bufNumR, transp=1, offset=0,attack=0.01,dur=1,release=0.5, pan=0, da=0|\cf0 \
	\cf3 var\cf0  env, chunkL, chunkR, inTrig;\
	inTrig = \cf3 InTrig\cf0 .kr(busTrig);\
	env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .linen(attack, (dur - attack - release), release, 1), gate: inTrig, doneAction: da);\
	chunkL = \cf3 PlayBuf\cf0 .ar(1, bufNumL, transp, inTrig, (offset.max(0).min(\cf3 BufDur\cf0 .kr(bufNumL) - dur) * \cf3 BufSampleRate\cf0 .kr(bufNumL)) );\
	chunkR = \cf3 PlayBuf\cf0 .ar(1, bufNumR, transp, inTrig, (offset.max(0).min(\cf3 BufDur\cf0 .kr(bufNumR) - dur) * \cf3 BufSampleRate\cf0 .kr(bufNumR)));\
	\cf3 Out\cf0 .ar( out, [chunkL, chunkR] * env );\
\}).send(~audio[\cf4 \\server\cf0 ]);\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf2 ////***********************************************************************************************\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 ////		Init Database + Build GUI...\cf0 \
\pard\pardeftab560\ql\qnatural
\cf0 \
\pard\pardeftab560\ql\qnatural
\cf2 // 6. evaluate the following to launch the GUI\cf0 \
(\
~crps = \cf3 CorpusDB\cf0 .new(\cf5 "manifold"\cf0 , s);\
\
~audio.add(\cf4 \\mBus\cf0  -> \cf3 Bus\cf0 .control(s, 1));\
~audio.add(\cf4 \\monoPlayer\cf0  -> \cf3 Synth\cf0 .new(\cf4 \\unitSamplerMono\cf0 , [\cf4 \\busTrig\cf0 , ~audio[\cf4 \\mBus\cf0 ]]));\
~audio.add(\cf4 \\sBus\cf0  -> \cf3 Bus\cf0 .control(s, 1));\
~audio.add(\cf4 \\stereoPlayer\cf0  -> \cf3 Synth\cf0 .new(\cf4 \\unitSamplerStereo\cf0 , [\cf4 \\busTrig\cf0 , ~audio[\cf4 \\sBus\cf0 ]]));\
\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 ////***********************************************************************************************\cf0 \
\cf2 ////		Begin GUI code\cf0 \
\cf2 ////\cf0 \
\cf2 //// window + top level container (tabbedView) + top level container views and storage\cf0 \
\
~gui = \cf3 Dictionary\cf0 [];\
~gui.add(\cf4 \\topWindow\cf0  -> \cf3 SCWindow\cf0 (\cf5 "manifold db"\cf0 , \cf3 Rect\cf0 (305, 75, 1120, 840)).acceptsMouseOver_(\cf3 true\cf0 ));\
~gui.add(\cf4 \\tabs\cf0  -> \cf3 Dictionary\cf0 []);\
~gui.add(\cf4 \\cf\cf0  -> 0)		\cf2 // 'helper' vars w/ more-or-less global scope\cf0 \
	.add(\cf4 \\cp\cf0  -> 0)\
	.add(\cf4 \\fileListDict\cf0  -> \cf3 Dictionary\cf0 [])\
	.add(\cf4 \\soundFileUnitRowViews\cf0  -> \cf3 Dictionary\cf0 []);\
\
~gui[\cf4 \\tabs\cf0 ].add(\cf4 \\view\cf0  -> \cf3 TabbedView\cf0 ( ~gui[\cf4 \\topWindow\cf0 ], \cf3 nil\cf0 , [\cf5 "import"\cf0 ,\cf5 "graph/db"\cf0 ], [\cf3 Color\cf0 .gray(0.25, 0.5)])\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 	.tabPosition_(\cf4 \\top\cf0 ).tabWidth_(70).tabHeight_(13).tabCurve_(3)\
	.backgrounds_([\cf3 Color\cf0 .gray(0.2)]).stringColor_(\cf3 Color\cf0 .white).stringFocusedColor_(\cf3 Color\cf0 .green));\
	\
~gui[\cf4 \\tabs\cf0 ][\cf4 \\view\cf0 ].views.do(\{ \cf3 |vw, ix|\cf0 \
	~gui[\cf4 \\tabs\cf0 ].add(ix -> \cf3 Dictionary\cf0 [\cf4 \\nameTag\cf0  -> [\cf4 \\importAnalyzeSegment\cf0 , \cf4 \\graph\cf0 , \cf4 \\scene\cf0 , \cf4 \\web\cf0 ][ix], \cf4 \\view\cf0  -> \cf3 SCScrollView\cf0 (~gui[\cf4 \\tabs\cf0 ][\cf4 \\view\cf0 ].views[ix], ~gui[\cf4 \\tabs\cf0 ][\cf4 \\view\cf0 ].views[ix].asView.bounds), \cf4 \\areas\cf0  -> \cf3 Dictionary\cf0 [], \cf4 \\needsUpdate\cf0  -> \cf3 true\cf0 ])\
\});\
\
\cf2 //// some additional behaviors for the top level views\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 ~gui[\cf4 \\topWindow\cf0 ].onClose_( \{\cf3 |ind|\cf0  [~audio[\cf4 \\mBus\cf0 ], ~audio[\cf4 \\sBus\cf0 ], ~audio[\cf4 \\monoPlayer\cf0 ], ~audio[\cf4 \\stereoPlayer\cf0 ], ~crps].do(\cf3 _\cf0 .free) \} );\
\
\cf2 //// containers/areas\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ].add(\cf4 \\waveform\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0, 0, 690, 160)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\analysis\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (-5, 165, 700, 420)).background_(\cf3 Color\cf0 .black))\
	.add(\cf4 \\filesList\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (700, 0, 415, 440)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\segBtns\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (5, 585, 25, 225)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\segments\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCScrollView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (25, 585, 1080, 225)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\highlighter\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (695, 445, 415, 170)));\
\
~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ].add(\cf4 \\graph\cf0  -> \cf3 CorpusUnitViewer\cf0 (~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0,0, 640, 640), ~crps, 5, 6, 7))\
	.add(\cf4 \\graphParams\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (650, 5, 360, 400)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\unitPlayer\cf0  -> \cf3 Dictionary\cf0 [\cf4 \\view\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (650, 650, 360, 160)).background_(\cf3 Color\cf0 .black)])\
	.add(\cf4 \\highlighter\cf0  -> \cf3 SCCompositeView\cf0 (~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (650, 405, 360, 240)));\
\
\cf2 //// waveform area\cf0 \
~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ].add(\cf4 \\fullView\cf0  -> \cf3 SCSoundFileView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0, 0, 690, 60))\
		.gridColor_(\cf3 Color\cf0 .gray)\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 		.action_())\
	.add(\cf4 \\zoomBar\cf0  -> \cf3 SCRangeSlider\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0, 60, 690, 20))\
		.lo_(0.0).hi_(1.0)\
		.mouseUpAction_(\{ \cf3 |slider|\cf0 \
			\cf3 var\cf0  zaRangeLo, zaRangeHi, zoomArray, temp;\
			\cf2 //"slider: ".post; slider.lo.post; slider.hi.postln;\cf0 \
			\cf3 var\cf0  cview = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\closeView\cf0 ];\
			cview.zoomToFrac(1);\
			cview.scrollToStart;\
			cview.zoom(slider.hi - slider.lo);\
			cview.scroll(slider.lo / (slider.hi - slider.lo));\
			zoomArray = ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\rawdescrs\cf0 ].flop;\
			zaRangeLo = (slider.lo * zoomArray[0].size).floor.asInteger;\
			zaRangeHi = (slider.hi * zoomArray[0].size).ceil.asInteger;\
			temp = zoomArray.collect(\{ \cf3 |row|\cf0  row[zaRangeLo..zaRangeHi] \});\
			\
			~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\analysis\cf0 ].children.do(\cf3 _\cf0 .remove);\
			\cf3 Plotter\cf0 (parent: ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\analysis\cf0 ])\
				.value_(temp)\
\pard\pardeftab560\ql\qnatural
\cf0 				.plotMode_(\cf4 \\linear\cf0 )\
				.superpose_(\cf3 false\cf0 )\
				.findSpecs_(\cf3 true\cf0 )\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf2 //				.editFunc_(\{|pl, pli, idx, val|\cf0 \
\cf2 //					pli.post; "...".post; idx.post; "....".post; val.postln;\cf0 \
\cf2 //					~crps[\\sfutable][~gui[\\cf]][\\rawdescrs][pli][idx] = val;\cf0 \
\cf2 //				\});\cf0 \
		\});\
)\
	.add(\cf4 \\closeView\cf0  -> \cf3 SCSoundFileView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (0, 80, 690, 80))\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 		.gridColor_(\cf3 Color\cf0 .gray)\
\pard\pardeftab560\ql\qnatural
\cf0 		.mouseUpAction_(\{ \cf3 |vw,x,y|\cf0 \
			\cf2 // update the data model\cf0 \
			~crps.updateSoundFileUnit(~gui[\cf4 \\cf\cf0 ], ~gui[\cf4 \\cp\cf0 ], \cf3 nil\cf0 ,\
				(~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\closeView\cf0 ].selectionStart(0) / 44.1).max(0).floor,\
				(~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\closeView\cf0 ].selectionSize(0) / 44.1).ceil);\
\
			\cf2 // update number boxes + fullView\cf0 \
			~updateSoundFileUnitRow.value(~gui[\cf4 \\cp\cf0 ], ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ][\cf4 \\fullView\cf0 ]);\
			\
			~crps.segmentUnits(~gui[\cf4 \\cf\cf0 ]);\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 			~gui[\cf4 \\soundFileUnitRowViews\cf0 ].keys.do(\{ \cf3 |pid|\cf0 \
				~gui[\cf4 \\soundFileUnitRowViews\cf0 ][pid][5].value_(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][pid][0..16].asString);\
			\});\
\pard\pardeftab560\ql\qnatural
\cf0 			~graphNeedsUpdate = \cf3 true\cf0 ;\
		\})\
	);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 \
\cf2 //// filesList area\cf0 \
~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ].add(\cf4 \\addFileButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (5, 5, 45, 20))\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 		.states_([[\cf5 "+file"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |bttn|\cf0 \
			\cf3 CocoaDialog\cf0 .getPaths(\{ \cf3 |paths|\cf0 \
				paths.do(\{ \cf3 |pth|\cf0 \
					\cf3 var\cf0  sf, thepath;\
					\cf3 var\cf0  fileListView = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ];\
					sf = \cf3 SoundFile\cf0 .openRead(pth.asString);\
					\cf2 //"SF: ".post; sf.post; " with ".post; sf.numChannels.post; " channels.".postln;\cf0 \
					(sf != \cf3 nil\cf0 ).if\
					\{\
						thepath = \cf3 PathName\cf0 .new(sf.path.asString);\
						~crps.addSoundFile(thepath.fullPath, sf.numChannels);\
						fileListView.items_((fileListView.items ++ [thepath.fileName]).asSet.asArray.sort);\
						~gui[\cf4 \\fileListDict\cf0 ].add(thepath.fileName -> thepath.fullPath);\
					\};\
					sf.close;\
				\});\
			\},\{	\cf5 "cancelled"\cf0 .postln \}, \cf3 false\cf0 );\
		\}))\
	.add(\cf4 \\addFolderButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (55, 5, 45, 20))\
		.states_([[\cf5 "+dir"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |bttn|\cf0 \
			\cf3 var\cf0  counter = 0;\
			\cf3 CocoaDialog\cf0 .getPaths(\{ \cf3 |paths|\cf0 \
				paths.do(\{ \cf3 |pth|\cf0 \
					\cf3 var\cf0  fileListView = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ];\
					\cf3 var\cf0  sf = \cf3 SoundFile\cf0 .openRead(pth.asString);\
					\cf3 var\cf0  thepath = \cf3 PathName\cf0 .new(sf.path.asString);\
					\cf3 var\cf0  thefiles = \cf3 PathName\cf0 .new(thepath.pathOnly.asString).files;\
					\cf3 var\cf0  theentries = \cf3 PathName\cf0 .new(thepath.pathOnly.asString).files;\
					counter = thefiles.size;\
					\cf3 AppClock\cf0 .sched(0.001, \
					\{\
						(counter > 0).if\
						\{ \
							~crps.addSoundFile(thefiles[counter - 1].fullPath, sf.numChannels);\
							fileListView.items_((fileListView.items ++ [theentries[counter - 1].fileName]).asSet.asArray.sort);\
							~gui[\cf4 \\fileListDict\cf0 ].add(theentries[counter - 1].fileName -> theentries[counter - 1].fullPath);\
							counter = counter - 1;\
							0.001\
						\} \{ sf.close; \cf3 nil\cf0  \};\
					\});\
				\});\
			\},\{\
				\cf5 "cancelled"\cf0 .postln;\
			\}, \cf3 false\cf0 );\
		\}))\
	.add(\cf4 \\removeFileButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (105, 5, 45, 20))\
		.states_([[\cf5 "-file"\cf0 , \cf3 Color\cf0 .red, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |btn|\cf0 \
			\cf3 var\cf0  findex = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].value;\
			\cf3 var\cf0  fname = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].items[ findex ];\
			\cf3 var\cf0  tmp = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].items;\
			tmp.removeAt(findex);\
			~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].items_(tmp);\
			~crps.removeSoundFile(~gui[\cf4 \\fileListDict\cf0 ][fname]);\
			~gui[\cf4 \\fileListDict\cf0 ].add(fname -> \cf3 nil\cf0 );\
			~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].valueAction_(0);\
		\}))\
	.add(\cf4 \\importButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (155, 5, 45, 20))\
		.states_([[\cf5 "import"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |btn|\cf0 \
			\cf3 CocoaDialog\cf0 .getPaths(\{ \cf3 |paths|\cf0 \
				paths.do(\{ \cf3 |pth|\cf0 \
					\cf3 var\cf0  thepath = \cf3 PathName\cf0 .new(pth.asString).fullPath.asString, tmp = \cf3 Array\cf0 [];\
					\cf3 var\cf0  fileListView = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ];\
					~crps.importCorpusFromXML(~audio[\cf4 \\server\cf0 ], thepath);\
					~crps[\cf4 \\sftable\cf0 ].keys.do(\{\cf3 |filename|\cf0 \
						tmp = tmp ++ [\cf3 PathName\cf0 .new(filename).fileName];\
						~gui[\cf4 \\fileListDict\cf0 ].add(\cf3 PathName\cf0 .new(filename).fileName -> \cf3 PathName\cf0 .new(filename).fullPath);\
					\});\
					\
					fileListView.items_((fileListView.items ++ tmp).asSet.asArray.sort);\
					\
					~graphNeedsUpdate = \cf3 true\cf0 ;\
\pard\pardeftab560\ql\qnatural
\cf0 				\});\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 			\},\{	\cf5 "cancelled"\cf0 .postln \}, \cf3 false\cf0 );\
		\}))\
	.add(\cf4 \\exportButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (205, 5, 45, 20))\
		.states_([[\cf5 "export"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |btn|\cf0 \
			\cf3 CocoaDialog\cf0 .savePanel(\{ \cf3 |path|\cf0 \
				~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\dropUnanalyzedButton\cf0 ].action.value;\
				~crps.exportCorpusToXML(~audio[\cf4 \\server\cf0 ], path);\
			\},\{\
				\cf5 "cancelled"\cf0 .postln;\
			\});\
		\}))\
	.add(\cf4 \\dropUnanalyzedButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (255, 5, 120, 20))\
		.states_([[\cf5 "-- drop unanalyzed"\cf0 , \cf3 Color\cf0 .red, \cf3 Color\cf0 .white]])\
		.value_(0)\
		.action_(\{ \cf3 |bttn|\cf0 \
			\cf3 var\cf0  tmp = \cf3 Array\cf0 [];\
			~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].items.do(\{ \cf3 |file|\cf0 \
				file.asString.postln;\
				(~crps[\cf4 \\sftable\cf0 ][~gui[\cf4 \\fileListDict\cf0 ][file.asString]][\cf4 \\abfr\cf0 ] != \cf3 nil\cf0 ).if\
				\{\
					tmp = tmp.add(file.asString);\
				\} \{\
					~crps.removeSoundFile(~gui[\cf4 \\fileListDict\cf0 ][file.asString]);\
				\};		\
			\});\
			~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\fileListView\cf0 ].items_(tmp.asSet.asArray.sort);\
		\}))\
	.add(\cf4 \\fileListView\cf0  -> \cf3 SCListView\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (5, 30, 400, 400))\
		.stringColor_(\cf3 Color\cf0 .white)\
		.selectedStringColor_(\cf3 Color\cf0 .green)\
		.items_([])\
		.action_(\{ \cf3 |q|\cf0 \
			\cf3 var\cf0  cf, sf, tmp, responder, responder2;\
			\cf2 // declare abbreviations for areas of the gui to be accessed:\cf0 \
			\cf3 var\cf0  waveformArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ], analysisArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\analysis\cf0 ], fileListArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\filesList\cf0 ];\
			\cf2 // empty ~soundFileUnits out\cf0 \
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ].do(\{ \cf3 |line|\cf0  line.pop; line.do(\{ \cf3 |elem|\cf0  elem.remove; elem.free \}) \});\
			~gui[\cf4 \\soundFileUnitRowViews\cf0 ] = \cf3 Dictionary\cf0 [];\
			\cf2 // get the menu selection and set current file global\cf0 \
			cf = ~gui[\cf4 \\fileListDict\cf0 ][ fileListArea[\cf4 \\fileListView\cf0 ].items[q.value] ];\
			~gui[\cf4 \\cf\cf0 ] = cf;\
			\cf2 // if non-nil, read out cached units into sfunitrows\cf0 \
			(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ] != \cf3 nil\cf0 ).if\
			\{\
				~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ].do(\{ \cf3 |pu, ix|\cf0 \
					~gui[\cf4 \\soundFileUnitRowViews\cf0 ] = ~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add(ix -> \
						~newSoundFileUnitRow.value(\
							~gui[\cf4 \\cf\cf0 ],\
							ix,\
							~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segments\cf0 ][\cf4 \\view\cf0 ],\
							waveformArea[\cf4 \\fullView\cf0 ],\
							waveformArea[\cf4 \\closeView\cf0 ]\
						);\
					)\
				\});\
			\} \{\
				\cf5 "...not cached... "\cf0 .postln;\
			\};\
			\cf2 // read sound file and stream or post analysis data\cf0 \
			sf = \cf3 SoundFile\cf0 .new;\
			(sf.openRead(cf) == \cf3 true\cf0 ).if\
			\{\
				fileListArea[\cf4 \\fileListView\cf0 ].enabled = \cf3 false\cf0 ;\
				waveformArea[\cf4 \\fullView\cf0 ].soundfile = sf;\
				waveformArea[\cf4 \\fullView\cf0 ].read(0, sf.numFrames);\
				waveformArea[\cf4 \\closeView\cf0 ].soundfile = sf;\
				waveformArea[\cf4 \\closeView\cf0 ].read(0, sf.numFrames);\
				\cf5 "window should refresh now!"\cf0 .postln;\
				~gui[\cf4 \\topWindow\cf0 ].refresh;\
				\
				(~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\rawdescrs\cf0 ] == \cf3 nil\cf0 ).if\
				\{	\cf2 // stream it\cf0 \
					\{~crps.analyzeSoundFile(cf)\}.fork(\cf3 SystemClock\cf0 );\
\cf2 //					// schedule the updates\cf0 \
					\{\
						while(\{\
							(~crps[\cf4 \\sftable\cf0 ][cf][\cf4 \\bfrL\cf0 ] == \cf3 nil\cf0 );\
						\},\{\
							~crps[\cf4 \\sftable\cf0 ][cf][\cf4 \\bfrL\cf0 ].postln;\
							0.1.wait;\
						\});\
						0.01.wait;\
						analysisArea.children.do(\cf3 _\cf0 .remove);\
\pard\pardeftab560\ql\qnatural
\cf0 						\cf3 Plotter\cf0 (parent: analysisArea)\
							.value_(~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\rawdescrs\cf0 ].flop)  \cf2 //[0]\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 							.plotMode_(\cf4 \\plines\cf0 )\
\pard\pardeftab560\ql\qnatural
\cf0 							.superpose_(\cf3 false\cf0 )\
							.findSpecs_(\cf3 true\cf0 )\
							.editFunc_(\{\cf3 |pl, pli, idx, val|\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 								pli.post; \cf5 "..."\cf0 .post; idx.post; \cf5 "...."\cf0 .post; val.postln;\
								~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\rawdescrs\cf0 ][pli][idx] = val;\
							\});\
						fileListArea[\cf4 \\fileListView\cf0 ].enabled = \cf3 true\cf0 ;\
					\}.fork(\cf3 AppClock\cf0 );\
\
				\} \{ \cf2 // post it if cached \cf0 \
					analysisArea.children.do(\cf3 _\cf0 .remove);\
\pard\pardeftab560\ql\qnatural
\cf0 					\cf3 Plotter\cf0 (parent: analysisArea)\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 						.value_(~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\rawdescrs\cf0 ].flop)  \cf2 //[0]\cf0 \
\pard\pardeftab560\ql\qnatural
\cf0 						.plotMode_(\cf4 \\plines\cf0 )\
						.superpose_(\cf3 false\cf0 )\
						.findSpecs_(\cf3 true\cf0 )\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 						.editFunc_(\{\cf3 |pl, pli, idx, val|\cf0 \
							pli.post; \cf5 "..."\cf0 .post; idx.post; \cf5 "...."\cf0 .post; val.postln;\
							~crps[\cf4 \\sfutable\cf0 ][cf][\cf4 \\rawdescrs\cf0 ][pli][idx] = val;\
						\});\
					\cf3 AppClock\cf0 .sched(0, \{ \cf3 |tm|\cf0  fileListArea[\cf4 \\fileListView\cf0 ].enabled = \cf3 true\cf0  \});\
				\};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 				[responder, responder2].do(\cf3 _\cf0 .remove; \cf3 _\cf0 .free);	\cf2 // clean up!\cf0 \
			\};\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 			\cf2 // update the sfviews (close and full) no matter what\cf0 \
			~updateSFViews.value(~gui[\cf4 \\cf\cf0 ], waveformArea[\cf4 \\fullView\cf0 ], waveformArea[\cf4 \\closeView\cf0 ], 0);\
		\}));\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf2 //// segments area\cf0 \
~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segBtns\cf0 ].add(\cf4 \\plusButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segBtns\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (2, 5, 20, 20))\
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 	.states_([[\cf5 "+"\cf0 ,\cf3 Color\cf0 .black,\cf3 Color\cf0 .white]])\
	.value_(0)\
	.mouseUpAction_(\{ \cf3 |bttn|\cf0 \
		\cf3 var\cf0  np, tmp;\
		\cf3 var\cf0  waveformArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ];\
		(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ] == \cf3 nil\cf0 ).if\
		\{\
			np = 0;\
			~crps.addSoundFileUnit(~gui[\cf4 \\cf\cf0 ], np, [0, 500]);\
		\} \{ \cf2 // else\cf0 \
			tmp = ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ].collect(\{ \cf3 |unit|\cf0  unit[4..5] \}).sort(\{\cf3 |a,b|\cf0  a[0] > b[0]\});\
			np = ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ].size;\
			~crps.addSoundFileUnit(~gui[\cf4 \\cf\cf0 ], np, [tmp[0][0] + tmp[0][1], 500]);\
		\};\
\
		~crps.segmentUnits(~gui[\cf4 \\cf\cf0 ]);\
		tmp = ~newSoundFileUnitRow.value(~gui[\cf4 \\cf\cf0 ], np, ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segments\cf0 ][\cf4 \\view\cf0 ], waveformArea[\cf4 \\fullView\cf0 ], waveformArea[\cf4 \\closeView\cf0 ]);\
		~gui[\cf4 \\soundFileUnitRowViews\cf0 ] = ~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add(np -> tmp);\
		waveformArea[\cf4 \\fullView\cf0 ].setSelection(np, ~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ][np][4..5] * 44.1);\
		~scheduleUpdates.value(1);\
	\});\
);\
~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segBtns\cf0 ].add(\cf4 \\fillButton\cf0  -> \cf3 SCButton\cf0 (~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segBtns\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (2, 30, 20, 20))\
	.states_([[\cf5 "->"\cf0 ,\cf3 Color\cf0 .black,\cf3 Color\cf0 .white]])\
	.value_(0)\
	.mouseUpAction_(\{ \cf3 |bttn|\cf0 \
		\cf3 var\cf0  last = ~gui[\cf4 \\soundFileUnitRowViews\cf0 ].size - 1;\
		\cf3 var\cf0  sfile = ~gui[\cf4 \\cf\cf0 ];\
		\cf3 var\cf0  sfid = ~crps[\cf4 \\sfmap\cf0 ].findKeyForValue(~gui[\cf4 \\cf\cf0 ]);\
		\cf3 var\cf0  waveformArea = ~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\waveform\cf0 ];\
		\cf2 // update the last one, filling to duration of sfile\cf0 \
		~crps.updateSoundFileUnit(sfile, last,\
			dur: (~crps[\cf4 \\sftable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\bfrL\cf0 ].duration * 1000) - ~crps.getSoundFileUnitMetadata(sfid , last)[4]);\
		(last > 0).if\
		\{	\
			((last - 1)..0).do(\{ \cf3 |pid|\cf0 \
				~crps.updateSoundFileUnit(sfile, pid,\
					dur: (~crps.getSoundFileUnitMetadata(sfid , pid + 1)[4] - ~crps.getSoundFileUnitMetadata(sfid , pid)[4]));\
			\});\
		\};\
		~gui[\cf4 \\soundFileUnitRowViews\cf0 ].do(\{ \cf3 |line|\cf0  line.pop; line.do(\{ \cf3 |elem|\cf0  elem.remove; elem.free \}) \});\
		~gui[\cf4 \\soundFileUnitRowViews\cf0 ] = \cf3 Dictionary\cf0 [];\
		\
		(~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ] != \cf3 nil\cf0 ).if\
		\{\
			~crps[\cf4 \\sfutable\cf0 ][~gui[\cf4 \\cf\cf0 ]][\cf4 \\units\cf0 ].do(\{ \cf3 |pu, ix|\cf0 \
				~gui[\cf4 \\soundFileUnitRowViews\cf0 ] = ~gui[\cf4 \\soundFileUnitRowViews\cf0 ].add(ix -> \
					~newSoundFileUnitRow.value(\
						~gui[\cf4 \\cf\cf0 ],\
						ix,\
						~gui[\cf4 \\tabs\cf0 ][0][\cf4 \\areas\cf0 ][\cf4 \\segments\cf0 ][\cf4 \\view\cf0 ],\
						waveformArea[\cf4 \\fullView\cf0 ],\
						waveformArea[\cf4 \\closeView\cf0 ]\
					);\
				)\
			\});\
		\};\
		~updateSFViews.value(~gui[\cf4 \\cf\cf0 ], waveformArea[\cf4 \\fullView\cf0 ], waveformArea[\cf4 \\closeView\cf0 ], 0);\
	\});\
);\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 \
\
\cf2 ////====================================================================================\cf0 \
\cf2 ////\cf0 \
\cf2 ////		Graph View (tabs.views[1])\cf0 \
\
~gui[\cf4 \\tabs\cf0 ][\cf4 \\view\cf0 ].focusActions[1] = \{\
	\cf5 "focussing!"\cf0 .postln;\
	(~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\needsUpdate\cf0 ] == \cf3 true\cf0 ).if\
	\{\
		\cf5 "init the graph"\cf0 .postln; \
		~buildGraphParams.value(1, 5, 6, 7, \cf3 nil\cf0 , \cf3 Color\cf0 .blue);\
		~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\needsUpdate\cf0 ] = \cf3 false\cf0 ;\
	\}\
\};\
\
~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ][\cf4 \\unitPlayer\cf0 ].add(\cf4 \\linkButton\cf0  -> \cf3 SCButton\cf0 .new( ~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ][\cf4 \\unitPlayer\cf0 ][\cf4 \\view\cf0 ], \cf3 Rect\cf0 (5, 5, 60, 20))\
	.states_([[\cf5 "touch"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .white], [\cf5 "search"\cf0 , \cf3 Color\cf0 .black, \cf3 Color\cf0 .green]])\
	.value_(0)\
	.mouseUpAction_(\{ \cf3 |btn|\cf0 \
		btn.value.postln;\
		(btn.value == 1).if\
		\{\
			~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ].setSearchFlag_(\cf3 false\cf0 );\
		\} \{\
			~gui[\cf4 \\tabs\cf0 ][1][\cf4 \\areas\cf0 ][\cf4 \\graph\cf0 ].setSearchFlag_(\cf3 true\cf0 );\
		\};\
	\});\
);\
\
\pard\pardeftab560\ql\qnatural
\cf2 // specify plot layout\cf0 \
\pard\pardeftab560\ql\qnatural
\cf3 GUI\cf0 .skin.plot.gridLinePattern = \cf3 FloatArray\cf0 [2, 1];\
\cf3 GUI\cf0 .skin.plot.fontColor = \cf3 Color\cf0 .white;\
\cf3 GUI\cf0 .skin.plot.gridColorX = \cf3 Color\cf0 .gray(0.75, 0.25);\
\cf3 GUI\cf0 .skin.plot.gridColorY = \cf3 Color\cf0 .gray(0.75, 0.25);\
\cf3 GUI\cf0 .skin.plot.background = \cf3 Color\cf0 .black;\
\cf3 GUI\cf0 .skin.plot.plotColor = \cf3 Color\cf0 .blue;\
\cf3 GUI\cf0 .skin.plot.labelX = \cf3 nil\cf0 ;\
\cf3 GUI\cf0 .skin.plot.labelY = \cf3 nil\cf0 ;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf0 \
\cf2 //// display the window + run "app"\cf0 \
\pard\pardeftab560\li1140\fi-1140\ql\qnatural
\cf0 ~gui[\cf4 \\topWindow\cf0 ].front;\
\
\pard\pardeftab560\ql\qnatural
\cf0 )}